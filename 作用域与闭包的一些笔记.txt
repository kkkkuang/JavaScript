函数声明和函数表达式：两者之前最重要的区别是名称标识符会被绑定在何处，
   1、函数申明必须要有函数名，必须是以function开头，但同时自身函数名可能会污染函数所处的作用域。
   2，函数表达式，可以不需要写函数名，其自身的函数名被隐藏的自己内部所处的作用域内，不会污染上一级的作用域；如(function (){...})()，自我执行。常见于回调函数中，为了重复调用方便，通常也会加上函数名。

   立即执行函数表达式（IIFE）：通常分为两种形式写法：（function（）{...}）()或者（function（）{...}(）);两者一致。IIFE也可以将参数传递进去。

   块级作用域：常见于在if(){}条件下的块级作用域。

    let:除了var之外的另一种定义变量的方式，可以将变量绑定到所在的任何的作用域中，可以形成一个块级作用域，比如：
	for(var i=0;i<10;i++){
		console.log(i);
	}
	console.log(i);  //无法输出
	与
	for(let i=0;i<10;i++){
		console.log(i);
	}
	console.log(i+10); //i=20,
	形成块级作用域，外部无法访问到i的值，避免污染。

    const：另一种创建块级作用域的方式，但定义的值只能为常量，如const b=3;任何修改b的值都会报错。

     编译器并不一定总是全部从上往下执行的，编译器会在代码执行之前，会将代码所有的变量声明先申明好，函数名会被申明，当函数名和变量名相同时，先被申明的是函数名，（var a=1）这种的只会先申明var a;而a=1只会在代码运行时才去赋值。


   关于闭包的理解：
	当一个A函数内部有另一个B函数，B函数引用了A的内部变量，并A函数的返回值是B时，此时产生了闭包；
	为什么要使用闭包呢？1，通常情况下，一个函数外部是无法访问到函数内部的变量的。而闭包可以达到这种目的，2，由于js的回收机制，一个函内部的变量在这个函数被执行完之后就会被回收，当有时候我们并不想回收这个变量，但是放在全局变量中又容易污染全局变量，此时，因为函数B对函数A的变量有引用，所有闭包可以使得这个变量长时间的留在内存中，函数A的作用域也会一直留在内存中；
  只要使用了回调函数，比如事件监听，ajax，定时器中，就存在闭包现象。
闭包的缺点：会使得作用域和变量会一直存在内存中。





























	